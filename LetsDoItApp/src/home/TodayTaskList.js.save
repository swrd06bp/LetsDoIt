
import React, { useState, useEffect } from 'react'
import { 
  View,
  Text,
  Image,
  SectionList,
  Vibration,
  ScrollView,
  SafeAreaView,
  TouchableOpacity,
  KeyboardAvoidingView,
} from 'react-native'
import { DraxProvider, DraxView } from 'react-native-drax'
import CheckBox from '@react-native-community/checkbox'
import Api from '../Api.js'
import AddTask from '../components/AddTask'

import {
  todayDate,
  decomposeTasksToday,
} from '../utils'

const move = (source, destination, droppableSource, droppableDestination) => {
    const sourceClone = Array.from(source)
    const destClone = Array.from(destination)
    const index = sourceClone.map(x=>x.id).indexOf(droppableDestination.id)
    const [removed] = sourceClone.splice(index, 1)

    destClone.splice(0, 0, removed)

    const result = {}
    result[droppableSource.droppableId] = sourceClone
    result[droppableDestination.droppableId] = destClone

    return result
}

const Item = (props) => {
  const [isOver, setIsOver] = useState(false)

  const onCheckboxChange = async () => {
    const api = new Api()
    await api.updateTask(props.item.id, {isDone: !props.item.isDone})
    props.onUpdate()
  }

  const onListChange = async () => {
    const api = new Api()
    await api.updateTask(props.item.id, {list: props.item.list === 'Personal' ? 'Work' : 'Personal'})
    props.onUpdate()

  }
  return(
    <View 
      style={{flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between'}}
    >
      <View style={{flexDirection: 'row', alignItems: 'center', width: '80%'}}> 
        <CheckBox 
          value={props.item.isDone}
          onValueChange={onCheckboxChange}
        />
        <View style={{flexGrow: 1, }} onClick={() => props.onDescribe(props.task ? null : props.item)}>
        <Text style={{fontSize:13, textDecorationLine: props.item.isDone ? 'line-through': null, color: props.item.isDone ? 'grey': 'black'}}>{props.item.content}</Text>
        </View>
      </View>
      <View style={{flexDirection: 'row', alignItems: 'center'}}>
        <TouchableOpacity 
          style={{backgroundColor: props.item.list === 'Personal' ? 'blue' : 'brown', borderRadius: 60}}
          onPress={onListChange}
        >
          <View style={{margin: 2}}>
            <Text style={{fontSize: 9, fontWeight: 'bold',  color: 'white'}}>{props.item.list}</Text>
          </View>
        </TouchableOpacity>
      
      </View>
    </View>
  )  
}

function TodayTaskList (props) {
  const [isRefreshing, setIsRefreshing] = useState(false)
  const [draggedTaskId, setDraggedTaskId] = React.useState(null)
  const [itemsUnfinished, setItemsUnifinished] = useState([])
  const [itemsToday, setItemsToday] = useState([])
  const [itemsTomorrow, setItemsTomorrow] = useState([])
  const [itemsUpcoming, setItemsUpcoming] = useState([])
  const [itemsSomeday, setItemsSomeday] = useState([])
  const api = new Api()


  useEffect(() => {
    getTasks() 
  },[props.task]) 


  const getTasks = async () => {
    setIsRefreshing(true)
    const response = await api.getTasks({from: todayDate().toJSON(), someday: true, unfinished: true})
    const allTasks = await response.json()

    if (allTasks) {
      const { unfinishedTasks, todayTasks, tomorrowTasks, upcomingTasks, somedayTasks } = decomposeTasksToday(allTasks)

      setItemsUnifinished(unfinishedTasks)
      setItemsToday(todayTasks)
      setItemsTomorrow(tomorrowTasks)
      setItemsUpcoming(upcomingTasks)
      setItemsSomeday(somedayTasks)
    }
    setIsRefreshing(false)
  }
  
  const id2List = {
    unfinished: itemsUnfinished,
    today: itemsToday,
    tomorrow: itemsTomorrow,
    upcoming: itemsUpcoming,
    someday: itemsSomeday,
  }

  const id2DueDate = id => {
    const matrix = {
      today: new Date().toJSON(),
      tomorrow: new Date(new Date().setDate(new Date().getDate() + 1)).toJSON(),
      upcoming: new Date(new Date().setDate(new Date().getDate() + 7)).toJSON(),
      someday: null,
    }
    return matrix[id]

  }

  const getList = id => id2List[id]

  const DATA = [
    {
      title: "Unfinished",
      data: itemsUnfinished 
    },
    {
      title: "Today",
      data: itemsToday 
    },
    {
      title: "Upcoming",
      data: itemsUpcoming 
    },
    {
      title: "Someday",
      data: itemsSomeday 
    }
  ]
  
  const onDragEnd = action => {
      const { source, destination } = action

      // dropped outside the list
      if (!destination) {
          return
      }

      if (source.droppableId !== destination.droppableId && destination.droppableId !== 'unfinished') {
          const result = move(
            getList(source.droppableId),
            getList(destination.droppableId),
            source,
            destination
          )

        if (result.unfinished)
          setItemsUnifinished(result.unfinished)
        if (result.today)
          setItemsToday(result.today)
        if (result.tomorrow)
          setItemsTomorrow(result.tomorrow)
        if (result.upcoming)
          setItemsUpcoming(result.upcoming)
        if (result.someday)
          setItemsSomeday(result.someday)

           
          api.updateTask(action.draggableId, {dueDate: id2DueDate(action.destination.droppableId)})
            .then(getTasks())
        }
    }

  return (
    <View>
      <SafeAreaView>
        <View style={{height: '80%'}}>
        <DraxProvider>
          <SectionList
            refreshing={isRefreshing}
            onRefresh={() => getTasks()}
            sections={DATA}
            keyExtractor={(item) => item.id}
            renderItem={({ item, section }) => (
              <DraxView
                renderContent={({ viewState }) => {
                  return (
                    <Item item={item} onUpdate={getTasks} />
                  )
                }}
                longPressDelay={1000}
                onDragStart={(event)=> {
                  console.log('enter', event, item.id, section)
                  setDraggedTaskId({id: item.id, droppableId: section.title})
                  Vibration.vibrate()
                }}
                onReceiveDragDrop={(event) => {
                  const destination = {droppableId: section.title}
                  onDragEnd({source: draggedTaskId, destination})
                  console.log('exit', event, item.id, section)
                }}
               />
            )}
            renderSectionHeader={({ section }) => {
              if (section.title === 'Unfinished' && !section.data.length)
                return null
              else {
                return (
                  <Text style={{fontSize: 18}}>{section.title}</Text>
                )
              }
            }}
          />     
          </DraxProvider>
        </View>
          <View style={{height: '20%', justifyContent: 'center'}}>
          <AddTask onUpdate={getTasks}/>
          </View>
      </SafeAreaView>
    </View>
  )
}



export default TodayTaskList
